# -*- coding: utf-8 -*-
"""TechStaX.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1T5hYBXE1O1AX3iySCapMVF-iUyFhZx8E
"""

import cv2
import numpy as np
import matplotlib.pyplot as plt

# Path to the image
path = '/content/img8.jpeg'

# Load the image
img = cv2.imread(path)
gray = cv2.imread(path, cv2.IMREAD_GRAYSCALE)

# Apply Gaussian blur to reduce noise
gray_blurred = cv2.GaussianBlur(gray, (5, 5), 0)

# Apply adaptive thresholding
thresh = cv2.adaptiveThreshold(
    gray_blurred, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
    cv2.THRESH_BINARY, 199, 5
)

# Detect edges
edges = cv2.Canny(thresh, 50, 150)

# Find contours
contours, hierarchy = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

# Find the largest contour->board
largest_contour = max(contours, key=cv2.contourArea)

# Approximate the largest contour to a polygon
epsilon = 0.02 * cv2.arcLength(largest_contour, True)
approx = cv2.approxPolyDP(largest_contour, epsilon, True)

# Ensure the largest contour has 4 sides
if len(approx) == 4:
    # Sort the corners of the polygon
    corners = approx[:, 0]
    corners = sorted(corners, key=lambda x: (x[1], x[0]))
    top_left, top_right = sorted(corners[:2], key=lambda x: x[0])
    bottom_left, bottom_right = sorted(corners[2:], key=lambda x: x[0])

    # Define the points for the perspective transform
    width = max(
        np.linalg.norm(top_right - top_left), np.linalg.norm(bottom_right - bottom_left)
    )
    height = max(
        np.linalg.norm(bottom_left - top_left), np.linalg.norm(bottom_right - top_right)
    )
    target_corners = np.array([
        [0, 0], [width - 1, 0],
        [width - 1, height - 1], [0, height - 1]
    ], dtype='float32')

    # Perform perspective transform
    matrix = cv2.getPerspectiveTransform(np.float32([top_left, top_right, bottom_right, bottom_left]), target_corners)
    board = cv2.warpPerspective(img, matrix, (int(width), int(height)))

    # Convert the corrected board to grayscale and threshold
    board_gray = cv2.cvtColor(board, cv2.COLOR_BGR2GRAY)
    board_thresh = cv2.adaptiveThreshold(
        board_gray, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 11, 2
    )

    # Divide the board into a grid and count black/white squares
    grid_size = 8  # Example for an 8x8 grid
    cell_height, cell_width = board_thresh.shape[0] // grid_size, board_thresh.shape[1] // grid_size
    black_squares, white_squares = 0, 0

    # Create a copy of the board to highlight individual squares
    highlighted_board = board.copy()

    for i in range(grid_size):
        for j in range(grid_size):
            # Calculate cell coordinates
            start_y, end_y = i * cell_height, (i + 1) * cell_height
            start_x, end_x = j * cell_width, (j + 1) * cell_width

            # Extract each cell
            cell = board_thresh[start_y:end_y, start_x:end_x]
            mean_intensity = np.mean(cell)

            # Determine cell color and draw rectangle
            color = (0, 0, 255) if mean_intensity < 128 else (0, 255, 0)  # Red for black, Green for white
            cv2.rectangle(highlighted_board, (start_x, start_y), (end_x, end_y), color, 2)

            # Count squares
            if mean_intensity < 128:
                black_squares += 1
            else:
                white_squares += 1

    # Create a figure to display images side by side
    fig, axes = plt.subplots(1, 6, figsize=(25, 5))

    # Display original image
    axes[0].imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
    axes[0].set_title("Original Image")
    axes[0].axis("off")

    # Display thresholded image
    axes[1].imshow(thresh, cmap="gray")
    axes[1].set_title("Thresholded Image")
    axes[1].axis("off")

    # Display edges
    axes[2].imshow(edges, cmap="gray")
    axes[2].set_title("Edges")
    axes[2].axis("off")

    # Display perspective-corrected board
    axes[3].imshow(cv2.cvtColor(board, cv2.COLOR_BGR2RGB))
    axes[3].set_title("Perspective-Corrected Board")
    axes[3].axis("off")

    # Display highlighted board with individual squares
    axes[4].imshow(cv2.cvtColor(highlighted_board, cv2.COLOR_BGR2RGB))
    axes[4].set_title("Highlighted Squares")
    axes[4].axis("off")

    # Display detected squares with count
    axes[5].imshow(cv2.cvtColor(board, cv2.COLOR_BGR2RGB))
    axes[5].set_title(f"Detected Squares\nBlack={black_squares}, White={white_squares}")
    axes[5].axis("off")

    # Show the figure
    plt.tight_layout()
    plt.show()

else:
    print("Failed to detect a quadrilateral board.")



